{"pages":[{"title":"关于我","text":"啦啦~~~","link":"/about/index.html"}],"posts":[{"title":"Java线程池学习","text":"","link":"/2022/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/"},{"title":"算法题[leetcode-2186]使两字符串互为字母异位词的最少步骤数","text":"题意给你两个字符串 s 和 t。在一步操作中，你可以给 s 或者 t 追加 任一字符 。 返回使 s 和 t 互为 字母异位词 所需的最少步骤数。 字母异位词 指字母相同但是顺序不同（或者相同）的字符串。示例 1： 输入：s = “leetcode”, t = “coats”输出：7解释： 执行 2 步操作，将 “as” 追加到 s = “leetcode” 中，得到 s = “leetcodeas” 。 执行 5 步操作，将 “leede” 追加到 t = “coats” 中，得到 t = “coatsleede” 。“leetcodeas” 和 “coatsleede” 互为字母异位词。总共用去 2 + 5 = 7 步。可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。 分析统计2字符串各字母出现的次数，把2个字符串的字母补充成一样即可。2边字符串各字母的差异数就是要操作的步骤数。 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int minSteps(String s, String t) { int[] chCntArrS = new int[26]; int[] chCntArrT = new int[26]; for (int i = 0; i &lt; s.length(); i++) { chCntArrS[s.charAt(i)-'a']++; } for (int i = 0; i &lt; t.length(); i++) { chCntArrT[t.charAt(i)-'a']++; } int cnt=0; for (int i = 0; i &lt; 26; i++) { cnt+=Math.abs(chCntArrS[i]-chCntArrT[i]); } return cnt; } public int minSteps2(String s, String t) { int[] chCntArr = new int[26]; for (int i = 0; i &lt; s.length(); i++) { chCntArr[s.charAt(i)-'a']++; } for (int i = 0; i &lt; t.length(); i++) { chCntArr[t.charAt(i)-'a']--; } int cnt=0; for (int i = 0; i &lt; 26; i++) { cnt+=Math.abs(chCntArr[i]); } return cnt; }} 题目地址：LeetCode","link":"/2022/%E7%AE%97%E6%B3%95%E9%A2%98-leetcode-2186-%E4%BD%BF%E4%B8%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E4%B8%BA%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E7%9A%84%E6%9C%80%E5%B0%91%E6%AD%A5%E9%AA%A4%E6%95%B0/"},{"title":"线上CPU告警问题排查","text":"排查步骤1、 收到告警信息，提示 Full GC耗时长，FullGC次数频繁，FullGC后Heap使用率异常超过了95%. 2、 登录grafana，查看系统监控指标，发现一台机器CPU使用率指标突然升高。 3、 联系运维同事，查看具体哪个线程占用CPU高。查看占用CPU高的线程命令 123top –Hp 进程号# 把线程号转为16进制printf &quot;%x\\n&quot; 线程号 4、保存jstack 信息到jstack.log文件，通过jstack文件确认占用CPU的是GC线程 1jstack -l 进程号 &gt; jstack.log 5、jmap命令查看java进程对象的分布情况，快速定位大对象的分布情况 12#前30个大对象jmap -histo:live 进程pid | head -n 30 通过histo查看的的对象实例情况，发现大量的poi.xssf包下的相关对象，基本确定是使用poi操作Excel导入导出功能产生大对象，导致一直FullGC。 6、保留gc日志，jstack和dump文件，重启应用恢复服务。 7、用MAT分析dump文件，确定是一个报表导出功能导致的。查询的报表数据量大且没有做分页处理，导出报表请求响应时间很长，用户在请求没有响应的情况下提交多次导出报表请求，最终导致生成了大量的对象占满了堆空间，但因为这些对象都不能回收，所以GC线程一直进行FullGC试图释放空间，最终的表象就是CPU使用率飙升。 改进措施1、针对导出功能，从业务上针对系统上所有导出功能进行梳理，评审相关代码；导出方案上，大数据量的情况下，分页查库和分sheet页写数据，同时考虑管理系统上所有的导出请求，把导出数据的请求放到一个队列中，排队依次处理导出请求，控制整个系统导出的数据量。 2、针对排查步骤，在通过 jmap -histo 命令基本确定是Excel导入导出相关功能产生大对象的情况下，可以直接在jstack文件或者日志文件中搜索 STUCK 关键字（针对weblogic），看是否有粘滞线程，如果有大概有就是这些粘滞线程导致的。","link":"/2022/%E7%BA%BF%E4%B8%8ACPU%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}]}