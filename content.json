{"pages":[{"title":"关于我","text":"啦啦~~~","link":"/about/index.html"}],"posts":[{"title":"Java线程池学习","text":"","link":"/2022/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/"},{"title":"算法题[leetcode-2186]使两字符串互为字母异位词的最少步骤数","text":"题意给你两个字符串 s 和 t。在一步操作中，你可以给 s 或者 t 追加 任一字符 。 返回使 s 和 t 互为 字母异位词 所需的最少步骤数。 字母异位词 指字母相同但是顺序不同（或者相同）的字符串。示例 1： 输入：s = “leetcode”, t = “coats”输出：7解释： 执行 2 步操作，将 “as” 追加到 s = “leetcode” 中，得到 s = “leetcodeas” 。 执行 5 步操作，将 “leede” 追加到 t = “coats” 中，得到 t = “coatsleede” 。“leetcodeas” 和 “coatsleede” 互为字母异位词。总共用去 2 + 5 = 7 步。可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。 分析统计2字符串各字母出现的次数，把2个字符串的字母补充成一样即可。2边字符串各字母的差异数就是要操作的步骤数。 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int minSteps(String s, String t) { int[] chCntArrS = new int[26]; int[] chCntArrT = new int[26]; for (int i = 0; i &lt; s.length(); i++) { chCntArrS[s.charAt(i)-'a']++; } for (int i = 0; i &lt; t.length(); i++) { chCntArrT[t.charAt(i)-'a']++; } int cnt=0; for (int i = 0; i &lt; 26; i++) { cnt+=Math.abs(chCntArrS[i]-chCntArrT[i]); } return cnt; } public int minSteps2(String s, String t) { int[] chCntArr = new int[26]; for (int i = 0; i &lt; s.length(); i++) { chCntArr[s.charAt(i)-'a']++; } for (int i = 0; i &lt; t.length(); i++) { chCntArr[t.charAt(i)-'a']--; } int cnt=0; for (int i = 0; i &lt; 26; i++) { cnt+=Math.abs(chCntArr[i]); } return cnt; }} 题目地址：LeetCode","link":"/2022/%E7%AE%97%E6%B3%95%E9%A2%98-leetcode-2186-%E4%BD%BF%E4%B8%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E4%B8%BA%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E7%9A%84%E6%9C%80%E5%B0%91%E6%AD%A5%E9%AA%A4%E6%95%B0/"},{"title":"线上CPU告警问题排查","text":"排查步骤1、 收到告警信息，提示 Full GC耗时长，FullGC次数频繁，FullGC后Heap使用率异常超过了95%. 2、 登录grafana，查看系统监控指标，发现一台机器CPU使用率指标突然升高。 3、 联系运维同事，查看具体哪个线程占用CPU高。查看占用CPU高的线程命令 123top –Hp 进程号# 把线程号转为16进制printf &quot;%x\\n&quot; 线程号 4、保存jstack 信息到jstack.log文件，通过jstack文件确认占用CPU的是GC线程 1jstack -l 进程号 &gt; jstack.log 5、jmap命令查看java进程对象的分布情况，快速定位大对象的分布情况 12#前30个大对象jmap -histo:live 进程pid | head -n 30 通过histo查看的的对象实例情况，发现大量的poi.xssf包下的相关对象，基本确定是使用poi操作Excel导入导出功能产生大对象，导致一直FullGC。 6、保留gc日志，jstack和dump文件，重启应用恢复服务。 7、用MAT分析dump文件，确定是一个报表导出功能导致的。查询的报表数据量大且没有做分页处理，导出报表请求响应时间很长，用户在请求没有响应的情况下提交多次导出报表请求，最终导致生成了大量的对象占满了堆空间，但因为这些对象都不能回收，所以GC线程一直进行FullGC试图释放空间，最终的表象就是CPU使用率飙升。 改进措施1、针对导出功能，从业务上针对系统上所有导出功能进行梳理，评审相关代码；导出方案上，大数据量的情况下，分页查库和分sheet页写数据，同时考虑管理系统上所有的导出请求，把导出数据的请求放到一个队列中，排队依次处理导出请求，控制整个系统导出的数据量。 2、针对排查步骤，在通过 jmap -histo 命令基本确定是Excel导入导出相关功能产生大对象的情况下，可以直接在jstack文件或者日志文件中搜索 STUCK 关键字（针对weblogic），看是否有粘滞线程，如果有大概有就是这些粘滞线程导致的。","link":"/2022/%E7%BA%BF%E4%B8%8ACPU%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"title":"如何阅读一本书 阅读笔记","text":"读书方法论读书层次分为：基础阅读，检视阅读，分析阅读和主题阅读，结合自身读书的目的，不同类型的书应采用不同的阅读方法。 以丰富自己的视野为目的的读书，大致阅读一下目录和序，了解讲了什么就可以。 以构建自身知识体系，补齐自身某些领域的短板，那需要详细阅读，挖掘书的核心关键词和关键论点，并将这些内容纳入到自己的知识体系中。 读书的步骤 第一步（站在月球看地球） 第二步（听作者讲） 第三步（与作者讨论） 第四步（思考与自身的联系） 结构 内容 评论 应用 书的分类？ 关键词/句 认可什么？ 与自己有什么联系或应用？ 主题谈的什么？ 核心观点是什么？ 不认可什么？ 能不能更好？ 框架大纲是什么？ 解决/未解决的问题？ 核心问题是什么？ 精华论述 精华评论 读书的笔记无论以何种方法阅读时都应该在阅读时做一些笔记，无论电子还是纸质。原因有二，一是在书写的过程中理清自己的观点和思路，二是方便复习加深记忆。 参考资料《如何阅读一本书》https://mp.weixin.qq.com/s/2ZR4sV9CoG-g-yT2MBSKkw","link":"/2022/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"},{"title":"Java通过线程名kill掉线程","text":"背景在生产环境，有时候因为代码bug或者数据量太大，导致某个线程死循环或者耗时非常长线程hang住了。在一些场景下，我们希望可以在不重启服务的情况下把这些线程终止了。 在 ActiveMQ 源码中发现一个通过线程名stop线程的方法，在此分享出来供参考。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.log4j.Logger;public class ThreadExplorer{ static Logger logger = Logger.getLogger(ThreadExplorer.class); public static Thread[] listThreads() { int nThreads = Thread.activeCount(); Thread ret[] = new Thread[nThreads]; Thread.enumerate(ret); return ret; } /** * Helper function to access a thread per name (ignoring case) * * @param name * @return */ public static Thread fetchThread(String name) { Thread[] threadArray = listThreads(); // for (Thread t : threadArray) for (int i = 0; i &lt; threadArray.length; i++) { Thread t = threadArray[i]; if (t.getName().equalsIgnoreCase(name)) return t; } return null; } /** * Allow for killing threads * * @param threadName * @param isStarredExp * (regular expressions with *) */ @SuppressWarnings(&quot;deprecation&quot;) public static int kill(String threadName, boolean isStarredExp) { String me = &quot;ThreadExplorer.kill: &quot;; if (logger.isDebugEnabled()) { logger.debug(&quot;Entering &quot; + me + &quot; with &quot; + threadName + &quot; isStarred: &quot; + isStarredExp); } int ret = 0; Pattern mypattern = null; if (isStarredExp) { String realreg = threadName.toLowerCase().replaceAll(&quot;\\\\*&quot;, &quot;\\\\.\\\\*&quot;); mypattern = Pattern.compile(realreg); } Thread[] threads = listThreads(); for (int i = 0; i &lt; threads.length; i++) { Thread thread = threads[i]; if (thread == null) continue; // kill the thread unless it is not current thread boolean matches = false; if (isStarredExp) { Matcher matcher = mypattern.matcher(thread.getName().toLowerCase()); matches = matcher.matches(); } else { matches = (thread.getName().equalsIgnoreCase(threadName)); } if (matches &amp;&amp; (Thread.currentThread() != thread) &amp;&amp; !thread.getName().equals(&quot;main&quot;)) { if (logger.isInfoEnabled()) logger.info(&quot;Killing thread named [&quot; + thread.getName() + &quot;]&quot;); // , removing its uncaught ret++; try { thread.stop(); } catch (ThreadDeath e) { logger.warn(&quot;Thread already death.&quot;, e); } } } return ret; } public static String show(String title) { StringBuffer out = new StringBuffer(); Thread[] threadArray = ThreadExplorer.listThreads(); out.append(title + &quot;\\n&quot;); for (int i = 0; i &lt; threadArray.length; i++) { Thread thread = threadArray[i]; if (thread != null) { out.append(&quot;* [&quot; + thread.getName() + &quot;] &quot; + (thread.isDaemon() ? &quot;(Daemon)&quot; : &quot;&quot;) + &quot; Group: &quot; + thread.getThreadGroup().getName() + &quot;\\n&quot;); } else { out.append(&quot;* ThreadDeath: &quot; + thread + &quot;\\n&quot;); } } return out.toString(); } public static int active() { int count = 0; Thread[] threadArray = ThreadExplorer.listThreads(); for (int i = 0; i &lt; threadArray.length; i++) { Thread thread = threadArray[i]; if (thread != null) { count++; } } return count; }} 示例12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class TestMain { public static void main(String[] args) throws IOException, InterruptedException { ExecutorService threadPool = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) { //10个线程死循环 int finalI = i; threadPool.execute(() -&gt; { for (;;){ try { Thread.sleep(10); } catch (InterruptedException e) { System.out.println(&quot;中断Thread#==&quot;+ finalI); e.printStackTrace(); } } }); } threadPool.shutdown(); System.out.println(ThreadExplorer.show(&quot;Kill thread 开始前线程#####&quot;)); ThreadExplorer.kill(&quot;pool-1-thread-1&quot;, false, &quot;&quot;); ThreadExplorer.kill(&quot;pool-1-thread-3&quot;, false, &quot;&quot;); //ThreadExplorer.kill(&quot;pool-1-thread-*&quot;, truer, &quot;&quot;);//stop所有线程名符合pool-1-thread-*的线程 Thread.sleep(1000);// 休眠只是为了后面能够打印的时候准确显示 System.out.println(ThreadExplorer.show(&quot;Kill thread 结束后剩余线程#####&quot;)); }} 示例结果1234567891011121314151617181920212223242526Kill thread 开始前线程#####* [main] Group: main* [pool-1-thread-1] Group: main* [pool-1-thread-2] Group: main* [pool-1-thread-3] Group: main* [pool-1-thread-4] Group: main* [pool-1-thread-5] Group: main* [pool-1-thread-6] Group: main* [pool-1-thread-7] Group: main* [pool-1-thread-8] Group: main* [pool-1-thread-9] Group: main* [pool-1-thread-10] Group: mainKilling thread named [pool-1-thread-1]Killing thread named [pool-1-thread-3]Kill thread 结束后剩余线程#####* [main] Group: main* [pool-1-thread-2] Group: main* [pool-1-thread-4] Group: main* [pool-1-thread-5] Group: main* [pool-1-thread-6] Group: main* [pool-1-thread-7] Group: main* [pool-1-thread-8] Group: main* [pool-1-thread-9] Group: main* [pool-1-thread-10] Group: main 从结果可以看到，线程pool-1-thread-1 和 pool-1-thread-3 已经被干掉了。","link":"/2022/Java%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E5%90%8Dkill%E6%8E%89%E7%BA%BF%E7%A8%8B/"},{"title":"PASETO简介","text":"PASETO 是什么？PASETO Token 的组成结构PASETO 是如何工作的？本地PASETO工作方式公共PASETO工作方式为什么使用PASETO Token(解决了什么问题)","link":"/2022/PASETO%E7%AE%80%E4%BB%8B/"},{"title":"学会提问阅读笔记","text":"框架大纲本书可分为三部分，前面2章介绍正确提问的好处和一些影响正确提问的障碍，后面章节介绍方法论。 正确提问的好处 干扰批判性思维的障碍 如何进行正确提问 核心观点 海绵式思维和淘金式思维。 淘金式思维：海绵式思维强调知识的获取，相对比较被动，无法提供判断获取的观点或方法是否可以相信。淘金式思维强调知识获取中的互动，淘金式思维要求读者问自己一系列既定的问题，以找出最佳的决策或信息。 影响正确批判思维的障碍。晕轮效应、可得性启发和自我为中心等 晕轮效应：有人做了令人讨厌的事，我们就觉得这人其他方方面面都变得讨厌，反之亦然。可以说是 先入为主或者第一印象 会影响其他的判断。 可得性启发和近因效应：可得性启发是指根据我们手边最容易获得的信息来形成结论。近因效应是指当人们识记一系列事物时对末尾部分项目的记忆效果优于中间部分项目的现象。","link":"/2022/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"方法论","slug":"方法论","link":"/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"PASETO","slug":"PASETO","link":"/tags/PASETO/"},{"name":"Token","slug":"Token","link":"/tags/Token/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"方法论","slug":"学习/方法论","link":"/categories/%E5%AD%A6%E4%B9%A0/%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"Web安全","slug":"Web安全","link":"/categories/Web%E5%AE%89%E5%85%A8/"}]}